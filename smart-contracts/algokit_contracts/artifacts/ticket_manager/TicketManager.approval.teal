#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8
    bytecblock "sold" "price" "supply" "organizer" "tickets" 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // algokit_contracts/ticket_manager.py:52
    // self.price = UInt64(0)
    bytec_1 // "price"
    intc_0 // 0
    app_global_put
    // algokit_contracts/ticket_manager.py:53
    // self.supply = UInt64(0)
    bytec_2 // "supply"
    intc_0 // 0
    app_global_put
    // algokit_contracts/ticket_manager.py:54
    // self.sold = UInt64(0)
    bytec_0 // "sold"
    intc_0 // 0
    app_global_put
    // algokit_contracts/ticket_manager.py:55
    // self.organizer = arc4.Address()
    bytec_3 // "organizer"
    global ZeroAddress
    app_global_put

main_after_if_else@2:
    // algokit_contracts/ticket_manager.py:35
    // class TicketManager(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@15
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x0b35099e 0x71ef5bd3 0xeca5246a 0x26fe2cdb 0xba90ab54 0xad9661f1 // method "create_event(uint64,uint64)void", method "buy_ticket(pay)uint64", method "claim_ticket(uint64)void", method "check_in(uint64)void", method "withdraw_funds(uint64)void", method "get_event_info()(uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match create_event buy_ticket claim_ticket check_in withdraw_funds get_event_info
    err

main___algopy_default_create@15:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// algokit_contracts.ticket_manager.TicketManager.create_event[routing]() -> void:
create_event:
    // algokit_contracts/ticket_manager.py:58
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // algokit_contracts/ticket_manager.py:61
    // assert Txn.sender == Global.creator_address, "Only creator can initialize"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // algokit_contracts/ticket_manager.py:62
    // self.price = price.native
    swap
    btoi
    bytec_1 // "price"
    swap
    app_global_put
    // algokit_contracts/ticket_manager.py:63
    // self.supply = supply.native
    btoi
    bytec_2 // "supply"
    swap
    app_global_put
    // algokit_contracts/ticket_manager.py:64
    // self.sold = UInt64(0)
    bytec_0 // "sold"
    intc_0 // 0
    app_global_put
    // algokit_contracts/ticket_manager.py:65
    // self.organizer = arc4.Address(Txn.sender)
    bytec_3 // "organizer"
    txn Sender
    app_global_put
    // algokit_contracts/ticket_manager.py:58
    // @arc4.abimethod()
    intc_1 // 1
    return


// algokit_contracts.ticket_manager.TicketManager.buy_ticket[routing]() -> void:
buy_ticket:
    // algokit_contracts/ticket_manager.py:67
    // @arc4.abimethod()
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // algokit_contracts/ticket_manager.py:74-75
    // # Validate payment
    // assert payment.receiver == Global.current_application_address, "Pay the contract"
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Pay the contract
    // algokit_contracts/ticket_manager.py:76
    // assert payment.amount == self.price, "Incorrect payment amount"
    gtxns Amount
    intc_0 // 0
    bytec_1 // "price"
    app_global_get_ex
    assert // check self.price exists
    ==
    assert // Incorrect payment amount
    // algokit_contracts/ticket_manager.py:77
    // assert self.sold < self.supply, "Sold out"
    intc_0 // 0
    bytec_0 // "sold"
    app_global_get_ex
    assert // check self.sold exists
    intc_0 // 0
    bytec_2 // "supply"
    app_global_get_ex
    assert // check self.supply exists
    dig 1
    >
    assert // Sold out
    // algokit_contracts/ticket_manager.py:79-80
    // # Increment sold count
    // self.sold += 1
    intc_1 // 1
    +
    bytec_0 // "sold"
    swap
    app_global_put
    // algokit_contracts/ticket_manager.py:84-92
    // itxn.AssetConfig(
    //     total=1,
    //     decimals=0,
    //     default_frozen=False,
    //     asset_name=b"TICKET",
    //     unit_name=b"TKT",
    //     manager=Global.current_application_address,
    // )
    // .submit()
    itxn_begin
    // algokit_contracts/ticket_manager.py:90
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    itxn_field ConfigAssetManager
    // algokit_contracts/ticket_manager.py:89
    // unit_name=b"TKT",
    pushbytes 0x544b54
    itxn_field ConfigAssetUnitName
    // algokit_contracts/ticket_manager.py:88
    // asset_name=b"TICKET",
    pushbytes 0x5449434b4554
    itxn_field ConfigAssetName
    // algokit_contracts/ticket_manager.py:87
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    // algokit_contracts/ticket_manager.py:86
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // algokit_contracts/ticket_manager.py:85
    // total=1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // algokit_contracts/ticket_manager.py:84
    // itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // algokit_contracts/ticket_manager.py:84-92
    // itxn.AssetConfig(
    //     total=1,
    //     decimals=0,
    //     default_frozen=False,
    //     asset_name=b"TICKET",
    //     unit_name=b"TKT",
    //     manager=Global.current_application_address,
    // )
    // .submit()
    itxn_submit
    // algokit_contracts/ticket_manager.py:84-93
    // itxn.AssetConfig(
    //     total=1,
    //     decimals=0,
    //     default_frozen=False,
    //     asset_name=b"TICKET",
    //     unit_name=b"TKT",
    //     manager=Global.current_application_address,
    // )
    // .submit()
    // .created_asset
    itxn CreatedAssetID
    // algokit_contracts/ticket_manager.py:98
    // owner=arc4.Address(Txn.sender),
    txn Sender
    // algokit_contracts/ticket_manager.py:99
    // status=arc4.UInt8(0),  # Pending
    pushbytes 0x00
    // algokit_contracts/ticket_manager.py:96-100
    // # Store ticket info in box
    // self.tickets[ticket_asset.id] = TicketInfo(
    //     owner=arc4.Address(Txn.sender),
    //     status=arc4.UInt8(0),  # Pending
    // )
    concat
    // algokit_contracts/ticket_manager.py:96-97
    // # Store ticket info in box
    // self.tickets[ticket_asset.id] = TicketInfo(
    swap
    itob
    bytec 4 // "tickets"
    dig 1
    concat
    // algokit_contracts/ticket_manager.py:96-100
    // # Store ticket info in box
    // self.tickets[ticket_asset.id] = TicketInfo(
    //     owner=arc4.Address(Txn.sender),
    //     status=arc4.UInt8(0),  # Pending
    // )
    uncover 2
    box_put
    // algokit_contracts/ticket_manager.py:67
    // @arc4.abimethod()
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// algokit_contracts.ticket_manager.TicketManager.claim_ticket[routing]() -> void:
claim_ticket:
    // algokit_contracts/ticket_manager.py:104
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // algokit_contracts/ticket_manager.py:110
    // asset_id = ticket_id.native
    btoi
    // algokit_contracts/ticket_manager.py:111
    // ticket = self.tickets[asset_id].copy()
    dup
    itob
    bytec 4 // "tickets"
    swap
    concat
    dup
    box_get
    assert // check self.tickets entry exists
    // algokit_contracts/ticket_manager.py:113-114
    // # Verify caller is the ticket owner
    // assert Txn.sender == ticket.owner.native, "Not the ticket owner"
    txn Sender
    dig 1
    extract 0 32
    swap
    dig 1
    ==
    assert // Not the ticket owner
    // algokit_contracts/ticket_manager.py:116-117
    // # Verify status is Pending (0)
    // assert ticket.status == arc4.UInt8(0), "Ticket already claimed"
    swap
    extract 32 1
    pushbytes 0x00
    b==
    assert // Ticket already claimed
    // algokit_contracts/ticket_manager.py:119-124
    // # Transfer NFT to buyer via inner transaction
    // itxn.AssetTransfer(
    //     xfer_asset=Asset(asset_id),
    //     asset_receiver=Txn.sender,
    //     asset_amount=1,
    // ).submit()
    itxn_begin
    // algokit_contracts/ticket_manager.py:122
    // asset_receiver=Txn.sender,
    txn Sender
    // algokit_contracts/ticket_manager.py:123
    // asset_amount=1,
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    uncover 2
    itxn_field XferAsset
    // algokit_contracts/ticket_manager.py:119-120
    // # Transfer NFT to buyer via inner transaction
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // algokit_contracts/ticket_manager.py:119-124
    // # Transfer NFT to buyer via inner transaction
    // itxn.AssetTransfer(
    //     xfer_asset=Asset(asset_id),
    //     asset_receiver=Txn.sender,
    //     asset_amount=1,
    // ).submit()
    itxn_submit
    // algokit_contracts/ticket_manager.py:129
    // status=arc4.UInt8(1),
    pushbytes 0x01
    // algokit_contracts/ticket_manager.py:126-130
    // # Update status to Claimed (1)
    // self.tickets[asset_id] = TicketInfo(
    //     owner=ticket.owner,
    //     status=arc4.UInt8(1),
    // )
    concat
    box_put
    // algokit_contracts/ticket_manager.py:104
    // @arc4.abimethod()
    intc_1 // 1
    return


// algokit_contracts.ticket_manager.TicketManager.check_in[routing]() -> void:
check_in:
    // algokit_contracts/ticket_manager.py:132
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // algokit_contracts/ticket_manager.py:138
    // asset_id = ticket_id.native
    btoi
    // algokit_contracts/ticket_manager.py:139
    // ticket = self.tickets[asset_id].copy()
    itob
    bytec 4 // "tickets"
    swap
    concat
    dup
    box_get
    assert // check self.tickets entry exists
    // algokit_contracts/ticket_manager.py:141-142
    // # Only organizer can verify
    // assert Txn.sender == self.organizer.native, "Only organizer"
    txn Sender
    intc_0 // 0
    bytec_3 // "organizer"
    app_global_get_ex
    assert // check self.organizer exists
    ==
    assert // Only organizer
    // algokit_contracts/ticket_manager.py:144-145
    // # Must be in Claimed (1) status
    // assert ticket.status == arc4.UInt8(1), "Ticket not in claimed state"
    dup
    extract 32 1
    pushbytes 0x01
    b==
    assert // Ticket not in claimed state
    // algokit_contracts/ticket_manager.py:149
    // owner=ticket.owner,
    extract 0 32
    // algokit_contracts/ticket_manager.py:150
    // status=arc4.UInt8(2),
    pushbytes 0x02
    // algokit_contracts/ticket_manager.py:147-151
    // # Update to Used (2)
    // self.tickets[asset_id] = TicketInfo(
    //     owner=ticket.owner,
    //     status=arc4.UInt8(2),
    // )
    concat
    box_put
    // algokit_contracts/ticket_manager.py:132
    // @arc4.abimethod()
    intc_1 // 1
    return


// algokit_contracts.ticket_manager.TicketManager.withdraw_funds[routing]() -> void:
withdraw_funds:
    // algokit_contracts/ticket_manager.py:153
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // algokit_contracts/ticket_manager.py:156
    // assert Txn.sender == self.organizer.native, "Only organizer"
    txn Sender
    intc_0 // 0
    bytec_3 // "organizer"
    app_global_get_ex
    assert // check self.organizer exists
    ==
    assert // Only organizer
    // algokit_contracts/ticket_manager.py:158-161
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=amount.native,
    // ).submit()
    itxn_begin
    // algokit_contracts/ticket_manager.py:159
    // receiver=Txn.sender,
    txn Sender
    // algokit_contracts/ticket_manager.py:160
    // amount=amount.native,
    swap
    btoi
    itxn_field Amount
    itxn_field Receiver
    // algokit_contracts/ticket_manager.py:158
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // algokit_contracts/ticket_manager.py:158-161
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=amount.native,
    // ).submit()
    itxn_submit
    // algokit_contracts/ticket_manager.py:153
    // @arc4.abimethod()
    intc_1 // 1
    return


// algokit_contracts.ticket_manager.TicketManager.get_event_info[routing]() -> void:
get_event_info:
    // algokit_contracts/ticket_manager.py:167
    // (arc4.UInt64(self.price), arc4.UInt64(self.supply), arc4.UInt64(self.sold))
    intc_0 // 0
    bytec_1 // "price"
    app_global_get_ex
    assert // check self.price exists
    itob
    intc_0 // 0
    bytec_2 // "supply"
    app_global_get_ex
    assert // check self.supply exists
    itob
    intc_0 // 0
    bytec_0 // "sold"
    app_global_get_ex
    assert // check self.sold exists
    itob
    // algokit_contracts/ticket_manager.py:166-168
    // return arc4.Tuple(
    //     (arc4.UInt64(self.price), arc4.UInt64(self.supply), arc4.UInt64(self.sold))
    // )
    cover 2
    concat
    swap
    concat
    // algokit_contracts/ticket_manager.py:163
    // @arc4.abimethod(readonly=True)
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
